[{"kind":2,"language":"magma","value":"//function that returns the Chayet--Garibaldi algebra of type G2 \n//field : the field of definition\n//O : octonion algebra over field\nfunction CGAlgebraG2(field,O);\n  //malcev product on O\n  function malcev(a,b);\n    return a*b-b*a;\n  end function;\n  //bilinear form on O, using eq 1.8 from SpringerVeldkamp\n  function norm(a,b);\n    dummy := -a*b - b*a +2*Eltseq(a)[1]*b + 2*Eltseq(a)[1]*b; \n    for i in [2..8] do\n      assert dummy[i] eq 0;\n    end for;\n    return dummy[1];\n  end function;\n  //straightforward map.\n  function sym(a,b);\n    return 1/2*(KroneckerProduct(a,b) + KroneckerProduct(b,a));\n  end function;\n  // V is the endomorphism space of operators\n  V := VectorSpace(field,8^2);\n  //This indexing represents a basis of the symmetric square of pure octonions\n  indexing := [];\n  for i in [2..8] do\n    for j in [i..8] do\n      Append(~indexing,[i,j]);\n    end for;\n  end for;\n  //construct a basis for the symmetric operators on the 7-dimensional space of pure octonions\n  basis:=[];\n  for index in indexing do\n    Append(~basis, V ! sym(O.(index[1]),O.(index[2])));\n  end for;\n  W:= RSpaceWithBasis(basis);\n  assert W.1 eq sym(O.2,O.2);\n  assert Dimension(W) eq 28;\n  //Multiplication from [D23], might be adapted to check whether any G2-equivariant product on this space admits a Killing metrized form with \"positive curvature operator\"\n  function mult(a,b,c,d);\n    term1 := norm(a,b)*sym(c,d) + norm(c,d)*sym(a,b);\n    term2 :=  norm(a,c)*sym(b,d) + norm(b,d)*sym(a,c) +norm(a,d)*sym(b,c) + norm(b,c)*sym(a,d);\n    term3 := sym(malcev(a,c),malcev(b,d)) + sym(malcev(a,d),malcev(b,c));\n    return 1/12*term1 + 1/12*term2 -1/48*term3;\n  end function;\n  // compute structure_constants\n  structure_constants := [];\n  for index1 in indexing do\n    row := [];\n    for index2 in indexing do\n      Append(~row, Coordinates(W, W ! mult(O.(index1[1]), O.(index1[2]), O.(index2[1]), O.(index2[2]))));\n    end for;\n    Append(~structure_constants,row);\n  end for;\n  // the algebra for g2\n  A := Algebra<field,28| structure_constants>;\n  //This is the counit, it is essentially the trace form on the symmetric operators of octonions\n  function counit(a);\n    test := Eltseq(a);\n    return (norm(O.2,O.2)*test[1]+norm(O.3,O.3)*test[8]+norm(O.4,O.4)*test[14]+norm(O.5,O.5)*test[19]+norm(O.6,O.6)*test[23]+norm(O.7,O.7)*test[26] +norm(O.8,O.8)*test[28])/7;\n  end function;\n  //function that converts pair of pure octonions to element of algebra\n  function OctoniontoA(a,b);\n    try\n      return A! Coordinates(W,W! sym(a,b));\n    catch e\n      error \"Error, make sure input is pair of pure octonions from the octonion algebra of definition.\";\n    end try;\n  end function;\n  //sanity check\n  assert counit(One(A)) eq 1;\n\n  return A,counit,OctoniontoA;\nend function;"},{"kind":1,"language":"markdown","value":"Below checks fusion table from Chapter 2."},{"kind":2,"language":"magma","value":"R<x> := PolynomialRing(Rationals());\nF<t> := NumberField(x^2+1);\nOct := OctonionAlgebra(F,-1,-1,-1);\nA,counit,pairtoA := CGAlgebraG2(F,Oct);\nidemp := pairtoA(Oct.2,Oct.2);\nassert idemp*idemp eq idemp;\nc := Oct.2;\nx := [Oct.3+ t*Oct.4, Oct.5 - t*Oct.6, Oct.7 - t*Oct.8];\ny := [Oct.3- t*Oct.4,Oct.5 +t*Oct.6,Oct.7 +t*Oct.8];\nassert Oct.3*Oct.4 eq Oct.2;\nassert -Oct.5*Oct.6 eq Oct.2;\nassert -Oct.7*Oct.8 eq Oct.2;\n\nhalf_eigenbasis_pos := [ pairtoA(c,x[i]) : i in [1..3] ];\nhalf_eigenbasis_neg := [ pairtoA(c,y[i]) : i in [1..3] ];\n\nzero_eigenbasis := [ pairtoA(x[i],y[j])  : i,j  in [1..3]| not j eq i];\nfor i in [1..3] do\n\tAppend(~zero_eigenbasis,(pairtoA(x[i],y[i]) - idemp/3));\nend for;\n\nthird_eigenbasis_pos := [pairtoA(x[i],x[j]): i,j in [1..3]| j ge i ];\nthird_eigenbasis_neg := [pairtoA(y[i],y[j]): i,j in [1..3]| j ge i ];\n\neigenvectorbasis := [idemp];\n\nfor elt in zero_eigenbasis do\n    assert idemp*elt eq Zero(A);\n    Append(~eigenvectorbasis,elt);\nend for;\n\nfor elt in half_eigenbasis_pos do\n    assert idemp*elt eq 1/2*elt;\n    Append(~eigenvectorbasis,elt);\nend for;\n\nfor elt in half_eigenbasis_neg do\n    assert idemp*elt eq 1/2*elt;\n    Append(~eigenvectorbasis,elt);\nend for;\n\nfor elt in third_eigenbasis_neg do\n    assert idemp*elt eq 1/3*elt ;\n    Append(~eigenvectorbasis,elt);\nend for;\n\nfor elt in third_eigenbasis_pos do\n    assert idemp*elt eq 1/3*elt;\n    Append(~eigenvectorbasis,elt);\nend for;\nA_new, isomorphism := ChangeBasis(A,eigenvectorbasis : Rep := \"Sparse\");\neigenvalues := [\"1\",\"0\",\"1/2+\",\"1/2-\",\"1/3-\",\"1/3+\"];\neigenvectors := [[idemp],zero_eigenbasis,half_eigenbasis_pos,half_eigenbasis_neg,third_eigenbasis_neg,third_eigenbasis_pos];\ntest := 0;\nendi_eigenspaces := [];\nfor i in [1..#eigenvectors] do\n\ttest := test + #eigenvectors[i];\n\tAppend(~endi_eigenspaces,test);\nend for;\n\nfusiontable := [*[*{} : j in [1..#eigenvalues]*]: i in [1..#eigenvalues]*];\n\nki :=1;\nfor i in [1..Dimension(A_new)] do\n\n\tif i gt endi_eigenspaces[ki] then\n\t\tki:= ki+1;\n\tend if;\n\n\tkj := ki;\n\n\tfor j in [i..Dimension(A_new)] do\n\n\t\tif j gt endi_eigenspaces[kj] then\n\t\t\tkj:= kj+1;\n\t\tend if;\n\n\t\ttest := BasisProduct(A_new,i,j);\n\t\ttest2 := Support(test);\n\t\n\n\t\tfor index in test2 do\n\t\t\tk := 1;\n\t\t\twhile k le #endi_eigenspaces and index gt endi_eigenspaces[k]  do\n\t\t\t\tk := k+1;\n\t\t\tend while;\n\t\t\tInclude(~fusiontable[ki,kj],eigenvalues[k]);\n\t\t\tInclude(~fusiontable[kj,ki],eigenvalues[k]);\n\t\tend for;\n\tend for;\nend for;\n\nfusiontable"}]